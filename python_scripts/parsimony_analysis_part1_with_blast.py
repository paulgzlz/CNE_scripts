# Usage: parsimony_analysis_part1.py merged_clusters tree blastn_dir

# Goal: run ancestral character state reconstruction tool PASTML to identify potentially convergent CNEs.

# Input: 
# merged_cne_clusters.csv: results of clustering analysis, generated by merge_homologous_cnes.py
# cnidarian_tree.nwk : phylogenetic tree in Newick format
# blastn_dir: directory of Blastn results against NCBI nt database. Used to idnetify presence of CNE in other species in the dataset
### even when CNEFinder did not find it (e.g. if similarity/length is lower)

# Output: pastml_output.html, contains dictionary of character states at each node for each CNE. Needs to be parsed
### with parsimony_analysis_part2.py

from pastml.acr import pastml_pipeline
import csv
import itertools
import pandas as pd
import sys
import pickle
import ast
from collections import Counter
import glob
from collections import defaultdict

merged_clusters = sys.argv[1]
tree = sys.argv[2]
blastn_dir = sys.argv[3]
blastn_files = glob.glob(blastn_dir + '*.blastn')

# Combine blastn_output and make it searchable by cne_id + subject_id
combined_df = pd.DataFrame(columns=['query_id','subject_id', 'pct_identity','aln_length', 'n_of_mismatches',
                 'gap_openings', 'q_start', 'q_end', 's_start', 's_end', 'e_value', 'bit_score',
                           'query_sp',  'subject_sp'])
for blastn_file in blastn_files:
    query_id = blastn_file.split("/")[-1].split('_combined_cnes')[0]
    subject_id = blastn_file.split("/")[-1].split('_vs_')[1].split(".")[0]
    sp_blast_df = pd.read_csv(blastn_file, sep="\t", 
          names=['query_id','subject_id', 'pct_identity','aln_length', 'n_of_mismatches',
                 'gap_openings', 'q_start', 'q_end', 's_start', 's_end', 'e_value', 'bit_score'])
    sp_blast_df.e_value = pd.to_numeric(sp_blast_df.e_value, errors='coerce')
    sp_blast_df = sp_blast_df[sp_blast_df['e_value'] < 0.01]
    sp_blast_df['query_sp'] = query_id
    sp_blast_df['subject_sp'] = subject_id
    combined_df = combined_df.append(sp_blast_df)

# Create dict of hit species for each CNE
cne_sp_dict = defaultdict(set)
for idx, row in combined_df.iterrows():
    cne_id = row['query_id']
    subject_id = row['subject_sp']
    cne_sp_dict[cne_id].add(subject_id)
    

# #### Species list
species_list = ['dgig',
                'ofav',
                'pdam',
                'spis',
                'adig', 
                'nvec',
                'epal',
                'aten', 
                'mvir',
                'aaur', 
                'chem',
                'hvul',
                'hsym'                                                                                       
               ]


# #### Dictionary of parent-child relationships
# 
# All species and nodes must be represented
tax_dict = { 
    'aaur': 'acraspeda',
    'adig': 'scleractinia',
    'aten': 'enthemonae',
    'chem': 'leptothecata',
    'dgig': 'anthozoa',
    'epal': 'enthemonae',
    'hsym': 'leptothecata',
    'hvul': 'hydrozoa',
    'mvir': 'acraspeda',
    'nvec': 'actiniaria',
    'ofav': 'robusta',
    'pdam': 'pocilloporidae',
    'spis': 'pocilloporidae',
    'pocilloporidae': 'robusta',
    'robusta': 'scleractinia',
    'scleractinia': 'hexacorallia',
    'enthemonae': 'actiniaria',
    'actiniaria': 'hexacorallia',
    'hexacorallia': 'anthozoa',
    'anthozoa': 'cnidaria',
    'hydractinia': 'anthoathecata',
    'leptothecata': 'hydrozoa',
    'hydrozoa': 'medusozoa',
    'acraspeda': 'medusozoa',
    'medusozoa': 'cnidaria'    
}


def retrieve_species_set(cluster_row):
    species_set = set()
    for cne in cluster_row:
        #print(cne)
        # Retrieve species ID and add to set
        species = cne.split("_cne_")[0]
        species_set.add(species)
        species_set = set.union(species_set, cne_sp_dict[cne])
    return(species_set)

# ### Create pastml input table
# 
# Rows: species ID  
# Columns: cluster id  
# 0: species not in cluster  
# 1: species in cluster

print("Creating pasml input table, this may take some time")
pastml_data = pd.DataFrame(species_list, columns=['id'])
with open(merged_clusters) as csvfile:
    cne_file = csv.reader(csvfile, delimiter = ',')
    cluster_counter = 0
    for row in cne_file:
        if cluster_counter % 100 == 0 :
            print(cluster_counter, "clusters processed")
        # species_set is the set of species in cluster
        cluster_id = row[0]
        cnes = row[1:]
        species_set = retrieve_species_set(cnes)
        pastml_data[cluster_id] = 0 # Fill all species with 0
        pastml_data[cluster_id] = pastml_data[cluster_id].astype(int) # Avoid automatic convert to float
        for species in species_set: # Add 1 to each species in cluster
            pastml_data.loc[pastml_data['id'] == species, cluster_id] = 1
        cluster_counter += 1

print("pastml table created. Writing to file: pastml_data.csv")

# #### Write pastml data to file
pastml_data_file = 'pastml_data.csv'
pastml_data.to_csv(pastml_data_file, index=False)
print("Done")

# Columns for which we want to reconstruct ancestral states
columns = list(pastml_data.columns)[1:] # everything except id column

# Path to the output compressed map visualisation
html_compressed = "pastml_output_compressed.html"

# (Optional) path to the output tree visualisation
html = "pastml_output.html"

print("Running pastml, this may take some time.")
pastml_pipeline(data=pastml_data_file, data_sep=',', columns=columns, name_column=columns[0], tree=tree,
                html_compressed=html_compressed, html=html, verbose=True)

print("pastml run complete.")
print("parse output html file using:")
print("grep elements pastml_output.html | sed 's/elements://g' | tr -d ' \t\n\r' | sed 's/.$//g' > pastml_output_dict.txt")
print("Then run parsimony_analysis_part2.py")


